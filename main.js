/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CMDSPACELinkEagle
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/types.ts
var DEFAULT_SETTINGS = {
  eagleApiBaseUrl: "http://localhost:41595",
  connectionTimeout: 5e3,
  thumbnailCacheTTL: 36e5,
  autoSyncOnOpen: false,
  tagPrefix: "",
  tagNormalization: "lowercase",
  linkFormat: "markdown",
  insertThumbnail: true,
  thumbnailSize: "medium",
  defaultFolder: "",
  r2WorkerUrl: "",
  r2ApiKey: "",
  r2PublicUrl: "",
  imageDisplayMode: "cloud",
  embedImageInCard: true,
  insertAsEmbed: true,
  imagePasteBehavior: "ask",
  activeCloudProvider: "imghippo",
  cloudProviders: {
    r2: {
      type: "r2",
      enabled: false,
      name: "Cloudflare R2",
      workerUrl: "",
      apiKey: "",
      publicUrl: ""
    },
    s3: {
      type: "s3",
      enabled: false,
      name: "Amazon S3",
      endpoint: "",
      region: "us-east-1",
      bucket: "",
      accessKeyId: "",
      secretAccessKey: "",
      publicUrl: ""
    },
    webdav: {
      type: "webdav",
      enabled: false,
      name: "WebDAV (Synology/NAS)",
      serverUrl: "",
      username: "",
      password: "",
      uploadPath: "/eagle-uploads",
      publicUrl: ""
    },
    imghippo: {
      type: "imghippo",
      enabled: false,
      name: "ImgHippo",
      apiKey: ""
    },
    custom: {
      type: "custom",
      enabled: false,
      name: "Custom Server",
      uploadUrl: "",
      headers: {},
      publicUrl: ""
    }
  }
};

// src/api.ts
var import_obsidian = require("obsidian");
var import_fs = require("fs");
var EagleApiService = class {
  constructor(settings) {
    this.baseUrl = settings.eagleApiBaseUrl;
    this.timeout = settings.connectionTimeout;
    this.r2WorkerUrl = settings.r2WorkerUrl;
    this.r2ApiKey = settings.r2ApiKey;
    this.r2PublicUrl = settings.r2PublicUrl;
  }
  updateSettings(settings) {
    this.baseUrl = settings.eagleApiBaseUrl;
    this.timeout = settings.connectionTimeout;
    this.r2WorkerUrl = settings.r2WorkerUrl;
    this.r2ApiKey = settings.r2ApiKey;
    this.r2PublicUrl = settings.r2PublicUrl;
  }
  async isConnected() {
    try {
      const info = await this.getApplicationInfo();
      return info !== null;
    } catch (e) {
      return false;
    }
  }
  async getApplicationInfo() {
    var _a;
    try {
      const response = await this.get("/api/application/info");
      return (_a = response.data) != null ? _a : null;
    } catch (e) {
      return null;
    }
  }
  async listItems(options) {
    var _a, _b, _c;
    const params = new URLSearchParams();
    if (options == null ? void 0 : options.keyword)
      params.append("keyword", options.keyword);
    if ((_a = options == null ? void 0 : options.tags) == null ? void 0 : _a.length)
      params.append("tags", options.tags.join(","));
    if ((_b = options == null ? void 0 : options.folders) == null ? void 0 : _b.length)
      params.append("folders", options.folders.join(","));
    if (options == null ? void 0 : options.ext)
      params.append("ext", options.ext);
    if (options == null ? void 0 : options.limit)
      params.append("limit", options.limit.toString());
    if (options == null ? void 0 : options.offset)
      params.append("offset", options.offset.toString());
    if (options == null ? void 0 : options.orderBy)
      params.append("orderBy", options.orderBy);
    const queryString = params.toString();
    const endpoint = queryString ? `/api/item/list?${queryString}` : "/api/item/list";
    const response = await this.get(endpoint);
    return (_c = response.data) != null ? _c : [];
  }
  async getItemInfo(id) {
    var _a;
    try {
      const response = await this.get(`/api/item/info?id=${id}`);
      return (_a = response.data) != null ? _a : null;
    } catch (e) {
      return null;
    }
  }
  async getThumbnailPath(id) {
    var _a;
    try {
      const response = await this.get(`/api/item/thumbnail?id=${id}`);
      return (_a = response.data) != null ? _a : null;
    } catch (e) {
      return null;
    }
  }
  async updateItem(id, updates) {
    try {
      const response = await this.post("/api/item/update", {
        id,
        ...updates
      });
      return response.status === "success";
    } catch (e) {
      return false;
    }
  }
  async addFromUrl(options) {
    try {
      const response = await this.post("/api/item/addFromURL", options);
      return response.status === "success";
    } catch (e) {
      return false;
    }
  }
  async addFromPath(options) {
    try {
      const response = await this.post("/api/item/addFromPath", options);
      if (response.status === "success" && response.data) {
        return { success: true, itemId: response.data };
      }
      return { success: false };
    } catch (e) {
      return { success: false };
    }
  }
  async listFolders() {
    var _a;
    try {
      const response = await this.get("/api/folder/list");
      return (_a = response.data) != null ? _a : [];
    } catch (e) {
      return [];
    }
  }
  async getLibraryInfo() {
    var _a;
    try {
      const response = await this.get("/api/library/info");
      return (_a = response.data) != null ? _a : null;
    } catch (e) {
      return null;
    }
  }
  async getLibraryPath() {
    var _a;
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `${this.baseUrl}/api/library/info`,
        method: "GET"
      });
      const json = response.json;
      console.log("[CMDS Eagle] library/info response:", json);
      if ((json == null ? void 0 : json.status) === "success" && ((_a = json == null ? void 0 : json.data) == null ? void 0 : _a.library)) {
        return json.data.library;
      }
      return null;
    } catch (e) {
      console.error("[CMDS Eagle] getLibraryPath error:", e);
      return null;
    }
  }
  async refreshThumbnail(id) {
    try {
      const response = await this.post("/api/item/refreshThumbnail", { id });
      return response.status === "success";
    } catch (e) {
      return false;
    }
  }
  async testR2Connection() {
    if (!this.r2WorkerUrl || !this.r2ApiKey) {
      return false;
    }
    try {
      const response = await (0, import_obsidian.requestUrl)({
        url: `${this.r2WorkerUrl}/health`,
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.r2ApiKey}`
        }
      });
      return response.status === 200;
    } catch (e) {
      return false;
    }
  }
  async getOriginalFilePath(item) {
    const libraryPath = await this.getLibraryPath();
    if (libraryPath) {
      const originalPath2 = `${libraryPath}/images/${item.id}.info/${item.name}.${item.ext}`;
      console.log("[CMDS Eagle] originalPath (from library):", originalPath2);
      return originalPath2;
    }
    const thumbnailPath = await this.getThumbnailPath(item.id);
    if (!thumbnailPath) {
      console.log("[CMDS Eagle] getThumbnailPath returned null for item:", item.id);
      return null;
    }
    console.log("[CMDS Eagle] thumbnailPath:", thumbnailPath);
    const decodedPath = this.safeDecodeUri(thumbnailPath);
    const folderPath = decodedPath.substring(0, decodedPath.lastIndexOf("/"));
    const originalPath = `${folderPath}/${item.name}.${item.ext}`;
    console.log("[CMDS Eagle] originalPath (from thumbnail):", originalPath);
    return originalPath;
  }
  safeDecodeUri(str) {
    try {
      return decodeURIComponent(str);
    } catch (e) {
      return str;
    }
  }
  async uploadToR2(item) {
    if (!this.r2WorkerUrl || !this.r2ApiKey || !this.r2PublicUrl) {
      return { success: false, error: "R2 settings not configured" };
    }
    const existingKey = getR2KeyFromItem(item);
    if (existingKey) {
      return {
        success: true,
        key: existingKey,
        filename: item.name
      };
    }
    try {
      const filePath = await this.getOriginalFilePath(item);
      if (!filePath) {
        return { success: false, error: "Could not get file path from Eagle" };
      }
      let fileBuffer;
      try {
        fileBuffer = await import_fs.promises.readFile(filePath);
      } catch (fsError) {
        return {
          success: false,
          error: `Could not read file: ${filePath}`
        };
      }
      const mimeType = getMimeType(item.ext);
      const blob = new Blob([fileBuffer], { type: mimeType });
      const filename = `${item.name}.${item.ext}`;
      const formData = new FormData();
      formData.append("file", blob, filename);
      formData.append("filename", filename);
      formData.append("content_type", mimeType);
      formData.append("eagle_id", item.id);
      const response = await fetch(`${this.r2WorkerUrl}/upload`, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.r2ApiKey}`
        },
        body: formData
      });
      if (!response.ok) {
        const errorText = await response.text();
        return { success: false, error: `Upload failed (${response.status}): ${errorText}` };
      }
      const result = await response.json();
      const r2Tag = `r2:${result.key}`;
      const newTags = [...item.tags];
      if (!newTags.includes(r2Tag)) {
        newTags.push(r2Tag);
      }
      if (!newTags.includes("r2-cloud")) {
        newTags.push("r2-cloud");
      }
      await this.updateItem(item.id, { tags: newTags });
      return {
        success: true,
        key: result.key,
        filename: result.filename
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  getCloudUrl(item) {
    const key = getR2KeyFromItem(item);
    if (!key || !this.r2PublicUrl) {
      return null;
    }
    return `${this.r2PublicUrl}/${key}`;
  }
  getLocalThumbnailUrl(id) {
    return `${this.baseUrl}/api/item/thumbnail?id=${id}`;
  }
  async get(endpoint) {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}${endpoint}`,
      method: "GET",
      headers: {
        "Content-Type": "application/json"
      }
    });
    return response.json;
  }
  async post(endpoint, body) {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${this.baseUrl}${endpoint}`,
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body)
    });
    return response.json;
  }
};
function buildEagleItemUrl(itemId) {
  return `eagle://item/${itemId}`;
}
function parseEagleUrl(url) {
  const itemMatch = url.match(/^eagle:\/\/item\/([A-Z0-9]+)$/i);
  if (itemMatch) {
    return { type: "item", id: itemMatch[1] };
  }
  const folderMatch = url.match(/^eagle:\/\/folder\/([A-Z0-9]+)$/i);
  if (folderMatch) {
    return { type: "folder", id: folderMatch[1] };
  }
  return null;
}
function parseEagleLocalhostUrl(url) {
  const match = url.match(/^https?:\/\/localhost:\d+\/item\?id=([A-Z0-9]+)$/i);
  if (match) {
    return match[1];
  }
  return null;
}
function isEagleLocalhostUrl(url) {
  return /^https?:\/\/localhost:\d+\/item\?id=[A-Z0-9]+$/i.test(url);
}
function getR2KeyFromItem(item) {
  const r2Tag = item.tags.find((t) => t.startsWith("r2:"));
  if (r2Tag) {
    return r2Tag.slice(3);
  }
  return null;
}
function hasR2Upload(item) {
  return item.tags.some((t) => t.startsWith("r2:"));
}
var MIME_TYPES = {
  "jpg": "image/jpeg",
  "jpeg": "image/jpeg",
  "png": "image/png",
  "gif": "image/gif",
  "webp": "image/webp",
  "svg": "image/svg+xml",
  "bmp": "image/bmp",
  "ico": "image/x-icon",
  "tiff": "image/tiff",
  "tif": "image/tiff"
};
function getMimeType(ext) {
  return MIME_TYPES[ext.toLowerCase()] || "application/octet-stream";
}

// src/modals.ts
var import_obsidian2 = require("obsidian");
var EagleSearchModal = class extends import_obsidian2.FuzzySuggestModal {
  constructor(app, api, settings) {
    super(app);
    this.items = [];
    this.isLoading = false;
    this.api = api;
    this.settings = settings;
    this.setPlaceholder("Search Eagle items by name, tags...");
    this.setInstructions([
      { command: "\u2191\u2193", purpose: "navigate" },
      { command: "\u21B5", purpose: "insert link" },
      { command: "esc", purpose: "dismiss" }
    ]);
  }
  async onOpen() {
    super.onOpen();
    await this.loadItems();
  }
  async loadItems() {
    if (this.isLoading)
      return;
    this.isLoading = true;
    try {
      const connected = await this.api.isConnected();
      if (!connected) {
        new import_obsidian2.Notice("Eagle is not running. Please start Eagle and try again.");
        this.close();
        return;
      }
      this.items = await this.api.listItems({ limit: 500 });
      this.inputEl.dispatchEvent(new Event("input"));
    } catch (error) {
      console.error("Failed to load Eagle items:", error);
      new import_obsidian2.Notice("Failed to load Eagle items. Check console for details.");
    } finally {
      this.isLoading = false;
    }
  }
  getItems() {
    return this.items;
  }
  getItemText(item) {
    const tags = item.tags.length > 0 ? ` [${item.tags.join(", ")}]` : "";
    const folders = item.folders.length > 0 ? ` /${item.folders.join("/")}` : "";
    return `${item.name}${tags}${folders}`;
  }
  renderSuggestion(match, el) {
    const item = match.item;
    const container = el.createDiv({ cls: "cmdspace-eagle-suggestion" });
    const infoDiv = container.createDiv({ cls: "cmdspace-eagle-suggestion-info" });
    infoDiv.createDiv({ cls: "cmdspace-eagle-suggestion-name", text: item.name });
    const metaDiv = infoDiv.createDiv({ cls: "cmdspace-eagle-suggestion-meta" });
    metaDiv.createSpan({ text: item.ext.toUpperCase() });
    metaDiv.createSpan({ text: " \u2022 " });
    metaDiv.createSpan({ text: this.formatFileSize(item.size) });
    if (item.width && item.height) {
      metaDiv.createSpan({ text: " \u2022 " });
      metaDiv.createSpan({ text: `${item.width}\xD7${item.height}` });
    }
    if (item.tags.length > 0) {
      const tagsDiv = infoDiv.createDiv({ cls: "cmdspace-eagle-suggestion-tags" });
      item.tags.slice(0, 5).forEach((tag) => {
        tagsDiv.createSpan({ cls: "cmdspace-eagle-tag", text: tag });
      });
      if (item.tags.length > 5) {
        tagsDiv.createSpan({ cls: "cmdspace-eagle-tag-more", text: `+${item.tags.length - 5}` });
      }
    }
  }
  onChooseItem(item, evt) {
    this.insertItemLink(item);
  }
  async insertItemLink(item) {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    if (!activeView) {
      new import_obsidian2.Notice("No active markdown editor");
      return;
    }
    const editor = activeView.editor;
    if (this.settings.insertAsEmbed) {
      const filePath = await this.api.getOriginalFilePath(item);
      if (filePath) {
        const fileUrl = this.pathToFileUrl(filePath);
        const filename = `${item.name}.${item.ext}`;
        let output = `![${filename}](${fileUrl})`;
        if (this.settings.insertThumbnail) {
          output += "\n\n" + this.buildMetadataLine(item);
        }
        editor.replaceSelection(output);
        new import_obsidian2.Notice(`Embedded: ${item.name}`);
        return;
      }
    }
    const linkUrl = buildEagleItemUrl(item.id);
    let linkText;
    if (this.settings.linkFormat === "wikilink") {
      linkText = `[[${linkUrl}|${item.name}]]`;
    } else {
      linkText = `[${item.name}](${linkUrl})`;
    }
    if (this.settings.insertThumbnail) {
      const card = this.buildLinkCard(item);
      editor.replaceSelection(card);
    } else {
      editor.replaceSelection(linkText);
    }
    new import_obsidian2.Notice(`Inserted link to: ${item.name}`);
  }
  pathToFileUrl(path) {
    const encodedPath = path.split("/").map((segment) => encodeURIComponent(segment)).join("/");
    return `file://${encodedPath}`;
  }
  buildMetadataLine(item) {
    const linkUrl = buildEagleItemUrl(item.id);
    const tags = item.tags.filter((t) => !t.startsWith("r2:") && t !== "r2-cloud" && t !== "cloud-upload").map((t) => `#${this.normalizeTag(t)}`).join(" ");
    const dimensions = item.width && item.height ? `${item.width}\xD7${item.height}` : "";
    return `> **${item.ext.toUpperCase()}** | ${this.formatFileSize(item.size)}${dimensions ? ` | ${dimensions}` : ""} | ${tags || "No tags"} | [Eagle](${linkUrl})`;
  }
  buildLinkCard(item) {
    const linkUrl = buildEagleItemUrl(item.id);
    const tags = item.tags.map((t) => `#${this.normalizeTag(t)}`).join(" ");
    const dimensions = item.width && item.height ? `${item.width}\xD7${item.height}` : "N/A";
    return `> [!cmdspace-eagle] ${item.name}
> 
> | Property | Value |
> |----------|-------|
> | **Type** | ${item.ext.toUpperCase()} |
> | **Size** | ${this.formatFileSize(item.size)} |
> | **Dimensions** | ${dimensions} |
> | **Tags** | ${tags || "None"} |
> ${item.annotation ? `> **Annotation**: ${item.annotation}
` : ""}
> [Open in Eagle](${linkUrl})

`;
  }
  normalizeTag(tag) {
    let normalized = tag.replace(/\s+/g, "-");
    if (this.settings.tagNormalization === "lowercase") {
      normalized = normalized.toLowerCase();
    }
    if (this.settings.tagPrefix) {
      normalized = `${this.settings.tagPrefix}/${normalized}`;
    }
    return normalized;
  }
  formatFileSize(bytes) {
    if (bytes < 1024)
      return `${bytes} B`;
    if (bytes < 1024 * 1024)
      return `${(bytes / 1024).toFixed(1)} KB`;
    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
  }
};
var ImagePasteChoiceModal = class extends import_obsidian2.Modal {
  constructor(app, cloudProviderName = "Cloud") {
    super(app);
    this.response = { rememberChoice: false };
    this.cloudProviderName = cloudProviderName;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("cmdspace-paste-choice-modal");
    contentEl.createEl("h2", { text: "Where to save image?" });
    const buttonContainer = contentEl.createDiv({ cls: "cmdspace-paste-buttons" });
    const eagleBtn = buttonContainer.createEl("button", {
      text: "Eagle (Local)",
      cls: "mod-cta"
    });
    eagleBtn.addEventListener("click", () => {
      this.response.choice = "eagle";
      this.close();
    });
    const localBtn = buttonContainer.createEl("button", { text: "Vault (Local)" });
    localBtn.addEventListener("click", () => {
      this.response.choice = "local";
      this.close();
    });
    const cloudBtn = buttonContainer.createEl("button", {
      text: `${this.cloudProviderName} (Cloud)`,
      cls: "mod-warning"
    });
    cloudBtn.addEventListener("click", () => {
      this.response.choice = "cloud";
      this.close();
    });
    new import_obsidian2.Setting(contentEl).setName("Remember this choice").setDesc("You can change this later in plugin settings").addToggle((toggle) => {
      toggle.setValue(false).onChange((value) => {
        this.response.rememberChoice = value;
      });
    });
  }
  onClose() {
    var _a, _b;
    if (this.resolvePromise) {
      this.resolvePromise({
        choice: (_a = this.response.choice) != null ? _a : "cancel",
        rememberChoice: (_b = this.response.rememberChoice) != null ? _b : false
      });
    }
  }
  getResponse() {
    return new Promise((resolve) => {
      this.resolvePromise = resolve;
    });
  }
};

// src/settings.ts
var import_obsidian3 = require("obsidian");
var CMDSPACEEagleSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "CMDS Eagle Settings" });
    containerEl.createEl("h3", { text: "Connection" });
    new import_obsidian3.Setting(containerEl).setName("Eagle API Base URL").setDesc("The base URL for Eagle's local API (default: http://localhost:41595)").addText((text) => text.setPlaceholder("http://localhost:41595").setValue(this.plugin.settings.eagleApiBaseUrl).onChange(async (value) => {
      this.plugin.settings.eagleApiBaseUrl = value || "http://localhost:41595";
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Connection Timeout").setDesc("Timeout in milliseconds for API requests").addText((text) => text.setPlaceholder("5000").setValue(this.plugin.settings.connectionTimeout.toString()).onChange(async (value) => {
      const num = parseInt(value, 10);
      if (!isNaN(num) && num > 0) {
        this.plugin.settings.connectionTimeout = num;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian3.Setting(containerEl).setName("Test Connection").setDesc("Check if Eagle is running and accessible").addButton((button) => button.setButtonText("Test").onClick(async () => {
      const api = new EagleApiService(this.plugin.settings);
      const info = await api.getApplicationInfo();
      if (info) {
        new import_obsidian3.Notice(`\u2713 Connected to Eagle ${info.version} (${info.platform})`);
      } else {
        new import_obsidian3.Notice("\u2717 Failed to connect to Eagle. Make sure Eagle is running.");
      }
    }));
    containerEl.createEl("h3", { text: "Image Paste/Drop Behavior" });
    new import_obsidian3.Setting(containerEl).setName("Default image behavior").setDesc("What to do when pasting or dropping images").addDropdown((dropdown) => dropdown.addOption("ask", "Ask every time").addOption("eagle", "Always upload to Eagle (local)").addOption("local", "Always save to vault (local)").addOption("cloud", "Always upload to cloud").setValue(this.plugin.settings.imagePasteBehavior).onChange(async (value) => {
      this.plugin.settings.imagePasteBehavior = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Search & Embed" });
    new import_obsidian3.Setting(containerEl).setName("Include metadata card").setDesc("Add metadata (type, size, tags, Eagle link) below the image when embedding").addToggle((toggle) => toggle.setValue(this.plugin.settings.insertThumbnail).onChange(async (value) => {
      this.plugin.settings.insertThumbnail = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Cloud Storage Provider" });
    new import_obsidian3.Setting(containerEl).setName("Active Cloud Provider").setDesc("Select which cloud storage to use for image uploads").addDropdown((dropdown) => dropdown.addOption("r2", "Cloudflare R2").addOption("imghippo", "ImgHippo (Free)").addOption("s3", "Amazon S3").addOption("webdav", "WebDAV (Synology/NAS)").addOption("custom", "Custom Server").setValue(this.plugin.settings.activeCloudProvider).onChange(async (value) => {
      this.plugin.settings.activeCloudProvider = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    this.renderCloudProviderSettings(containerEl);
    containerEl.createEl("hr", { attr: { style: "margin: 24px 0; border: none; border-top: 1px solid var(--background-modifier-border);" } });
    const footerEl = containerEl.createEl("div", { attr: { style: "text-align: center; color: var(--text-muted); font-size: 12px;" } });
    footerEl.createEl("div", { text: `CMDS Eagle v${this.plugin.manifest.version}`, attr: { style: "margin-bottom: 8px;" } });
    const linksEl = footerEl.createEl("div");
    const eduLink = linksEl.createEl("a", { text: "CMDSPACE Education", href: "https://class.cmdspace.kr/" });
    eduLink.setAttr("target", "_blank");
    linksEl.createSpan({ text: " \xB7 " });
    const ytLink = linksEl.createEl("a", { text: "YouTube", href: "https://www.youtube.com/@cmdspace" });
    ytLink.setAttr("target", "_blank");
  }
  renderCloudProviderSettings(containerEl) {
    const provider = this.plugin.settings.activeCloudProvider;
    const providerContainer = containerEl.createDiv({ cls: "cloud-provider-settings" });
    switch (provider) {
      case "imghippo":
        this.renderImgHippoSettings(providerContainer);
        break;
      case "r2":
        this.renderR2Settings(providerContainer);
        break;
      case "s3":
        this.renderS3Settings(providerContainer);
        break;
      case "webdav":
        this.renderWebDAVSettings(providerContainer);
        break;
      case "custom":
        this.renderCustomSettings(providerContainer);
        break;
    }
  }
  renderR2Settings(containerEl) {
    containerEl.createEl("h4", { text: "Cloudflare R2 Settings" });
    const infoEl = containerEl.createEl("div", { cls: "setting-item-description" });
    infoEl.style.marginBottom = "12px";
    infoEl.innerHTML = `
			<p style="margin: 0 0 8px 0;">Cloudflare R2 requires a Worker for uploads. Setup:</p>
			<ol style="margin: 0; padding-left: 20px;">
				<li>Create an R2 bucket in Cloudflare dashboard</li>
				<li>Deploy the Eagle Cloud Worker (see plugin docs)</li>
				<li>Copy Worker URL and API Key below</li>
			</ol>
		`;
    new import_obsidian3.Setting(containerEl).setName("Worker URL").setDesc("Cloudflare Worker URL (must end with .workers.dev)").addText((text) => text.setPlaceholder("https://eagle-uploader.xxx.workers.dev").setValue(this.plugin.settings.cloudProviders.r2.workerUrl).onChange(async (value) => {
      let url = value.trim();
      if (url && !url.startsWith("http")) {
        url = "https://" + url;
      }
      url = url.replace(/\/$/, "");
      this.plugin.settings.cloudProviders.r2.workerUrl = url;
      this.plugin.settings.cloudProviders.r2.enabled = !!(url && this.plugin.settings.cloudProviders.r2.apiKey);
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("API Key").setDesc("API_KEY from Cloudflare Worker Variables").addText((text) => text.setPlaceholder("your-api-key-here").setValue(this.plugin.settings.cloudProviders.r2.apiKey).onChange(async (value) => {
      this.plugin.settings.cloudProviders.r2.apiKey = value.trim();
      this.plugin.settings.cloudProviders.r2.enabled = !!(this.plugin.settings.cloudProviders.r2.workerUrl && value.trim());
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Public URL").setDesc("R2 bucket public URL (starts with pub-)").addText((text) => text.setPlaceholder("https://pub-xxx.r2.dev").setValue(this.plugin.settings.cloudProviders.r2.publicUrl).onChange(async (value) => {
      this.plugin.settings.cloudProviders.r2.publicUrl = value.trim().replace(/\/$/, "");
      await this.plugin.saveSettings();
    }));
  }
  renderImgHippoSettings(containerEl) {
    containerEl.createEl("h4", { text: "ImgHippo Settings (Free Image Hosting)" });
    const infoEl = containerEl.createEl("div", { cls: "setting-item-description" });
    infoEl.style.marginBottom = "12px";
    infoEl.innerHTML = `
			<p style="margin: 0 0 8px 0;">ImgHippo is a free image hosting service. To get your API key:</p>
			<ol style="margin: 0; padding-left: 20px;">
				<li>Visit <a href="https://www.imghippo.com/">imghippo.com</a> and sign up/login</li>
				<li>Go to <a href="https://www.imghippo.com/settings">Settings page</a></li>
				<li>Copy your API key and paste it below</li>
			</ol>
		`;
    new import_obsidian3.Setting(containerEl).setName("API Key").setDesc("Your ImgHippo API key from the settings page").addText((text) => text.setPlaceholder("Your ImgHippo API key").setValue(this.plugin.settings.cloudProviders.imghippo.apiKey).onChange(async (value) => {
      this.plugin.settings.cloudProviders.imghippo.apiKey = value.trim();
      this.plugin.settings.cloudProviders.imghippo.enabled = !!value.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Test Connection").setDesc("Verify API key is valid").addButton((button) => button.setButtonText("Test").onClick(async () => {
      const config = this.plugin.settings.cloudProviders.imghippo;
      if (!config.apiKey) {
        new import_obsidian3.Notice("\u2717 Please enter an API key first");
        return;
      }
      new import_obsidian3.Notice("\u2713 ImgHippo API key configured");
    }));
  }
  renderS3Settings(containerEl) {
    containerEl.createEl("h4", { text: "Amazon S3 Settings" });
    new import_obsidian3.Setting(containerEl).setName("Endpoint").setDesc("S3-compatible endpoint URL").addText((text) => text.setPlaceholder("https://s3.amazonaws.com").setValue(this.plugin.settings.cloudProviders.s3.endpoint).onChange(async (value) => {
      this.plugin.settings.cloudProviders.s3.endpoint = value.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Region").addText((text) => text.setPlaceholder("us-east-1").setValue(this.plugin.settings.cloudProviders.s3.region).onChange(async (value) => {
      this.plugin.settings.cloudProviders.s3.region = value.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Bucket").addText((text) => text.setPlaceholder("my-bucket").setValue(this.plugin.settings.cloudProviders.s3.bucket).onChange(async (value) => {
      this.plugin.settings.cloudProviders.s3.bucket = value.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Access Key ID").addText((text) => text.setValue(this.plugin.settings.cloudProviders.s3.accessKeyId).onChange(async (value) => {
      this.plugin.settings.cloudProviders.s3.accessKeyId = value.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Secret Access Key").addText((text) => text.setValue(this.plugin.settings.cloudProviders.s3.secretAccessKey).onChange(async (value) => {
      this.plugin.settings.cloudProviders.s3.secretAccessKey = value.trim();
      this.plugin.settings.cloudProviders.s3.enabled = !!(this.plugin.settings.cloudProviders.s3.endpoint && this.plugin.settings.cloudProviders.s3.accessKeyId && value.trim());
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Public URL (optional)").setDesc("Custom public URL for accessing uploaded files").addText((text) => text.setPlaceholder("https://cdn.example.com").setValue(this.plugin.settings.cloudProviders.s3.publicUrl).onChange(async (value) => {
      this.plugin.settings.cloudProviders.s3.publicUrl = value.trim();
      await this.plugin.saveSettings();
    }));
  }
  renderWebDAVSettings(containerEl) {
    containerEl.createEl("h4", { text: "WebDAV Settings" });
    containerEl.createEl("p", {
      text: "Works with Synology NAS, Nextcloud, ownCloud, or any WebDAV server.",
      cls: "setting-item-description"
    });
    new import_obsidian3.Setting(containerEl).setName("Server URL").addText((text) => text.setPlaceholder("https://nas.example.com/webdav").setValue(this.plugin.settings.cloudProviders.webdav.serverUrl).onChange(async (value) => {
      this.plugin.settings.cloudProviders.webdav.serverUrl = value.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Username").addText((text) => text.setValue(this.plugin.settings.cloudProviders.webdav.username).onChange(async (value) => {
      this.plugin.settings.cloudProviders.webdav.username = value.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Password").addText((text) => text.setValue(this.plugin.settings.cloudProviders.webdav.password).onChange(async (value) => {
      this.plugin.settings.cloudProviders.webdav.password = value;
      this.plugin.settings.cloudProviders.webdav.enabled = !!(this.plugin.settings.cloudProviders.webdav.serverUrl && this.plugin.settings.cloudProviders.webdav.username && value);
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Upload Path").setDesc("Directory path for uploads").addText((text) => text.setPlaceholder("/eagle-uploads").setValue(this.plugin.settings.cloudProviders.webdav.uploadPath).onChange(async (value) => {
      this.plugin.settings.cloudProviders.webdav.uploadPath = value.trim() || "/eagle-uploads";
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Public URL").setDesc("Public URL prefix for accessing uploaded files").addText((text) => text.setPlaceholder("https://public.example.com").setValue(this.plugin.settings.cloudProviders.webdav.publicUrl).onChange(async (value) => {
      this.plugin.settings.cloudProviders.webdav.publicUrl = value.trim();
      await this.plugin.saveSettings();
    }));
  }
  renderCustomSettings(containerEl) {
    containerEl.createEl("h4", { text: "Custom Server Settings" });
    containerEl.createEl("p", {
      text: 'Configure a custom upload endpoint. Server should accept multipart/form-data with "file" field.',
      cls: "setting-item-description"
    });
    new import_obsidian3.Setting(containerEl).setName("Upload URL").addText((text) => text.setPlaceholder("https://your-server.com/upload").setValue(this.plugin.settings.cloudProviders.custom.uploadUrl).onChange(async (value) => {
      this.plugin.settings.cloudProviders.custom.uploadUrl = value.trim();
      this.plugin.settings.cloudProviders.custom.enabled = !!value.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Public URL").setDesc("Base URL for accessing uploaded files").addText((text) => text.setPlaceholder("https://cdn.your-server.com").setValue(this.plugin.settings.cloudProviders.custom.publicUrl).onChange(async (value) => {
      this.plugin.settings.cloudProviders.custom.publicUrl = value.trim();
      await this.plugin.saveSettings();
    }));
  }
};

// src/cloud-providers.ts
var import_fs2 = require("fs");
function getMimeType2(ext) {
  const MIME_TYPES2 = {
    "jpg": "image/jpeg",
    "jpeg": "image/jpeg",
    "png": "image/png",
    "gif": "image/gif",
    "webp": "image/webp",
    "svg": "image/svg+xml",
    "bmp": "image/bmp",
    "ico": "image/x-icon",
    "tiff": "image/tiff",
    "tif": "image/tiff",
    "pdf": "application/pdf"
  };
  return MIME_TYPES2[ext.toLowerCase()] || "application/octet-stream";
}
var R2Provider = class {
  constructor(config) {
    this.config = config;
  }
  async upload(filePath, filename, mimeType) {
    if (!this.config.workerUrl || !this.config.apiKey) {
      return { success: false, error: "R2 not configured" };
    }
    try {
      const fileBuffer = await import_fs2.promises.readFile(filePath);
      const blob = new Blob([fileBuffer], { type: mimeType });
      const formData = new FormData();
      formData.append("file", blob, filename);
      formData.append("filename", filename);
      formData.append("content_type", mimeType);
      const response = await fetch(`${this.config.workerUrl}/upload`, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.config.apiKey}`
        },
        body: formData
      });
      if (!response.ok) {
        const errorText = await response.text();
        return { success: false, error: `Upload failed (${response.status}): ${errorText}` };
      }
      const result = await response.json();
      return {
        success: true,
        key: result.key,
        filename: result.filename,
        publicUrl: this.getPublicUrl(result.key)
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async testConnection() {
    if (!this.config.workerUrl || !this.config.apiKey) {
      return false;
    }
    try {
      const response = await fetch(`${this.config.workerUrl}/health`, {
        method: "GET",
        headers: {
          "Authorization": `Bearer ${this.config.apiKey}`
        }
      });
      return response.status === 200;
    } catch (e) {
      return false;
    }
  }
  getPublicUrl(key) {
    return `${this.config.publicUrl}/${key}`;
  }
};
var S3Provider = class {
  constructor(config) {
    this.config = config;
  }
  async upload(filePath, filename, mimeType) {
    if (!this.config.endpoint || !this.config.accessKeyId || !this.config.secretAccessKey) {
      return { success: false, error: "S3 not configured" };
    }
    try {
      const fileBuffer = await import_fs2.promises.readFile(filePath);
      const key = `eagle/${Date.now()}-${filename}`;
      const date = new Date().toISOString().replace(/[:-]|\.\d{3}/g, "");
      const dateStamp = date.slice(0, 8);
      const host = new URL(this.config.endpoint).host;
      const canonicalUri = `/${this.config.bucket}/${key}`;
      const canonicalQueryString = "";
      const payloadHash = await this.sha256(fileBuffer);
      const canonicalHeaders = [
        `content-type:${mimeType}`,
        `host:${host}`,
        `x-amz-content-sha256:${payloadHash}`,
        `x-amz-date:${date}`
      ].join("\n") + "\n";
      const signedHeaders = "content-type;host;x-amz-content-sha256;x-amz-date";
      const canonicalRequest = [
        "PUT",
        canonicalUri,
        canonicalQueryString,
        canonicalHeaders,
        signedHeaders,
        payloadHash
      ].join("\n");
      const algorithm = "AWS4-HMAC-SHA256";
      const credentialScope = `${dateStamp}/${this.config.region}/s3/aws4_request`;
      const stringToSign = [
        algorithm,
        date,
        credentialScope,
        await this.sha256(new TextEncoder().encode(canonicalRequest))
      ].join("\n");
      const signingKey = await this.getSignatureKey(
        this.config.secretAccessKey,
        dateStamp,
        this.config.region,
        "s3"
      );
      const signature = await this.hmacHex(signingKey, stringToSign);
      const authorizationHeader = `${algorithm} Credential=${this.config.accessKeyId}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${signature}`;
      const response = await fetch(`${this.config.endpoint}/${this.config.bucket}/${key}`, {
        method: "PUT",
        headers: {
          "Content-Type": mimeType,
          "x-amz-content-sha256": payloadHash,
          "x-amz-date": date,
          "Authorization": authorizationHeader
        },
        body: fileBuffer
      });
      if (!response.ok) {
        const errorText = await response.text();
        return { success: false, error: `S3 upload failed (${response.status}): ${errorText}` };
      }
      return {
        success: true,
        key,
        filename,
        publicUrl: this.getPublicUrl(key)
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async testConnection() {
    if (!this.config.endpoint || !this.config.accessKeyId) {
      return false;
    }
    try {
      const response = await fetch(`${this.config.endpoint}/${this.config.bucket}`, {
        method: "HEAD"
      });
      return response.status < 500;
    } catch (e) {
      return false;
    }
  }
  getPublicUrl(key) {
    if (this.config.publicUrl) {
      return `${this.config.publicUrl}/${key}`;
    }
    return `${this.config.endpoint}/${this.config.bucket}/${key}`;
  }
  async sha256(data) {
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    return Array.from(new Uint8Array(hashBuffer)).map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  async hmac(key, data) {
    const cryptoKey = await crypto.subtle.importKey(
      "raw",
      key,
      { name: "HMAC", hash: "SHA-256" },
      false,
      ["sign"]
    );
    return await crypto.subtle.sign("HMAC", cryptoKey, new TextEncoder().encode(data));
  }
  async hmacHex(key, data) {
    const sig = await this.hmac(key, data);
    return Array.from(new Uint8Array(sig)).map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  async getSignatureKey(key, dateStamp, region, service) {
    const kDate = await this.hmac(new TextEncoder().encode("AWS4" + key), dateStamp);
    const kRegion = await this.hmac(kDate, region);
    const kService = await this.hmac(kRegion, service);
    return await this.hmac(kService, "aws4_request");
  }
};
var WebDAVProvider = class {
  constructor(config) {
    this.config = config;
  }
  async upload(filePath, filename, mimeType) {
    if (!this.config.serverUrl || !this.config.username) {
      return { success: false, error: "WebDAV not configured" };
    }
    try {
      const fileBuffer = await import_fs2.promises.readFile(filePath);
      const key = `${this.config.uploadPath}/${Date.now()}-${filename}`;
      const uploadUrl = `${this.config.serverUrl}${key}`;
      const auth = btoa(`${this.config.username}:${this.config.password}`);
      const response = await fetch(uploadUrl, {
        method: "PUT",
        headers: {
          "Authorization": `Basic ${auth}`,
          "Content-Type": mimeType
        },
        body: fileBuffer
      });
      if (!response.ok && response.status !== 201 && response.status !== 204) {
        return { success: false, error: `WebDAV upload failed (${response.status})` };
      }
      return {
        success: true,
        key,
        filename,
        publicUrl: this.getPublicUrl(key)
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async testConnection() {
    if (!this.config.serverUrl || !this.config.username) {
      return false;
    }
    try {
      const auth = btoa(`${this.config.username}:${this.config.password}`);
      const response = await fetch(this.config.serverUrl, {
        method: "PROPFIND",
        headers: {
          "Authorization": `Basic ${auth}`,
          "Depth": "0"
        }
      });
      return response.status === 207 || response.status === 200;
    } catch (e) {
      return false;
    }
  }
  getPublicUrl(key) {
    if (this.config.publicUrl) {
      return `${this.config.publicUrl}${key}`;
    }
    return `${this.config.serverUrl}${key}`;
  }
};
var ImgHippoProvider = class {
  constructor(config) {
    this.config = config;
    this.API_URL = "https://api.imghippo.com/v1/upload";
  }
  async upload(filePath, filename, mimeType) {
    var _a, _b;
    if (!this.config.apiKey) {
      return { success: false, error: "ImgHippo API key not configured" };
    }
    try {
      const fileBuffer = await import_fs2.promises.readFile(filePath);
      const blob = new Blob([fileBuffer], { type: mimeType });
      const formData = new FormData();
      formData.append("api_key", this.config.apiKey);
      formData.append("file", blob, filename);
      formData.append("title", filename);
      const response = await fetch(this.API_URL, {
        method: "POST",
        body: formData
      });
      if (!response.ok) {
        const errorText = await response.text();
        return { success: false, error: `ImgHippo upload failed (${response.status}): ${errorText}` };
      }
      const result = await response.json();
      if (!result.success || !result.data) {
        return { success: false, error: result.message || "Upload failed" };
      }
      const publicUrl = result.data.url || result.data.display_url || ((_a = result.data.image) == null ? void 0 : _a.url);
      const resultFilename = ((_b = result.data.image) == null ? void 0 : _b.filename) || result.data.title || filename;
      if (!publicUrl) {
        return { success: false, error: "No URL returned from ImgHippo" };
      }
      return {
        success: true,
        key: result.data.id,
        filename: resultFilename,
        publicUrl
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async testConnection() {
    return !!this.config.apiKey;
  }
  getPublicUrl(key) {
    return key;
  }
};
var CustomProvider = class {
  constructor(config) {
    this.config = config;
  }
  async upload(filePath, filename, mimeType) {
    if (!this.config.uploadUrl) {
      return { success: false, error: "Custom provider not configured" };
    }
    try {
      const fileBuffer = await import_fs2.promises.readFile(filePath);
      const blob = new Blob([fileBuffer], { type: mimeType });
      const formData = new FormData();
      formData.append("file", blob, filename);
      formData.append("filename", filename);
      const response = await fetch(this.config.uploadUrl, {
        method: "POST",
        headers: this.config.headers,
        body: formData
      });
      if (!response.ok) {
        const errorText = await response.text();
        return { success: false, error: `Upload failed (${response.status}): ${errorText}` };
      }
      const result = await response.json();
      const key = result.key || result.url || filename;
      return {
        success: true,
        key,
        filename: result.filename || filename,
        publicUrl: this.getPublicUrl(key)
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  async testConnection() {
    if (!this.config.uploadUrl) {
      return false;
    }
    try {
      const response = await fetch(this.config.uploadUrl, {
        method: "HEAD",
        headers: this.config.headers
      });
      return response.status < 500;
    } catch (e) {
      return false;
    }
  }
  getPublicUrl(key) {
    if (this.config.publicUrl) {
      return key.startsWith("http") ? key : `${this.config.publicUrl}/${key}`;
    }
    return key;
  }
};
function createCloudProvider(config) {
  switch (config.type) {
    case "r2":
      return new R2Provider(config);
    case "s3":
      return new S3Provider(config);
    case "webdav":
      return new WebDAVProvider(config);
    case "imghippo":
      return new ImgHippoProvider(config);
    case "custom":
      return new CustomProvider(config);
    default:
      return null;
  }
}
function getExtFromFilename(filename) {
  const parts = filename.split(".");
  return parts.length > 1 ? parts[parts.length - 1].toLowerCase() : "";
}

// src/main.ts
var CMDSPACELinkEagle = class extends import_obsidian4.Plugin {
  async onload() {
    console.log("Loading CMDSPACE Link: Eagle");
    await this.loadSettings();
    this.api = new EagleApiService(this.settings);
    this.addCommand({
      id: "search-eagle",
      name: "Search Eagle library and embed",
      editorCallback: (editor, view) => {
        new EagleSearchModal(this.app, this.api, this.settings).open();
      }
    });
    this.addCommand({
      id: "upload-clipboard-to-cloud",
      name: "Upload clipboard Eagle image to cloud",
      editorCallback: async (editor, view) => {
        await this.uploadClipboardToCloud(editor);
      }
    });
    this.addCommand({
      id: "embed-and-upload",
      name: "Embed Eagle image and upload to cloud",
      editorCallback: async (editor, view) => {
        await this.embedAndUploadToCloud(editor);
      }
    });
    this.addCommand({
      id: "convert-all-to-cloud",
      name: "Convert all images in note to cloud URLs",
      callback: async () => {
        await this.uploadAllImagesToCloud();
      }
    });
    this.registerEvent(
      this.app.workspace.on("editor-paste", async (evt, editor) => {
        await this.handlePaste(evt, editor);
      })
    );
    this.registerEvent(
      this.app.workspace.on("editor-drop", async (evt, editor) => {
        await this.handleDrop(evt, editor);
      })
    );
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor) => {
        const localImage = this.getLocalImageUnderCursor(editor);
        if (localImage) {
          menu.addItem((item) => {
            item.setTitle("Upload to Eagle").setIcon("upload").onClick(() => this.uploadLocalImageToEagle(editor, localImage));
          });
        }
      })
    );
    this.addSettingTab(new CMDSPACEEagleSettingTab(this.app, this));
    this.registerMarkdownPostProcessor((el, ctx) => {
      this.processEagleLinks(el);
    });
    this.addRibbonIcon("image", "CMDSPACE: Eagle", () => {
      new EagleSearchModal(this.app, this.api, this.settings).open();
    });
  }
  onunload() {
    console.log("Unloading CMDSPACE Link: Eagle");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.api) {
      this.api.updateSettings(this.settings);
    }
  }
  async insertFromClipboard(editor) {
    const clipboardText = await navigator.clipboard.readText();
    const parsed = parseEagleUrl(clipboardText.trim());
    if (!parsed || parsed.type !== "item") {
      new import_obsidian4.Notice("Clipboard does not contain a valid Eagle item URL");
      return;
    }
    const item = await this.api.getItemInfo(parsed.id);
    if (!item) {
      new import_obsidian4.Notice("Could not fetch item info from Eagle");
      return;
    }
    this.insertItemLink(editor, item);
    new import_obsidian4.Notice(`Inserted link to: ${item.name}`);
  }
  async insertItemLink(editor, item) {
    if (this.settings.insertAsEmbed) {
      const filePath = await this.api.getOriginalFilePath(item);
      if (filePath) {
        const fileUrl = this.pathToFileUrl(filePath);
        const filename = `${item.name}.${item.ext}`;
        let output = `![${filename}](${fileUrl})`;
        if (this.settings.insertThumbnail) {
          output += "\n\n" + this.buildMetadataCard(item);
        }
        editor.replaceSelection(output);
        return;
      }
    }
    const linkUrl = buildEagleItemUrl(item.id);
    if (this.settings.insertThumbnail) {
      const card = this.buildLinkCard(item);
      editor.replaceSelection(card);
    } else {
      const link = this.settings.linkFormat === "wikilink" ? `[[${linkUrl}|${item.name}]]` : `[${item.name}](${linkUrl})`;
      editor.replaceSelection(link);
    }
  }
  buildMetadataCard(item) {
    const linkUrl = buildEagleItemUrl(item.id);
    const tags = item.tags.filter((t) => !t.startsWith("r2:") && t !== "r2-cloud" && t !== "cloud-upload").map((t) => `#${this.normalizeTag(t)}`).join(" ");
    const dimensions = item.width && item.height ? `${item.width}\xD7${item.height}` : "N/A";
    const isUploaded = hasR2Upload(item);
    const cloudUrl = this.api.getCloudUrl(item);
    let linkSection = `[Open in Eagle](${linkUrl})`;
    if (cloudUrl) {
      linkSection += ` | [Cloud](${cloudUrl})`;
    }
    return `> **${item.ext.toUpperCase()}** | ${this.formatFileSize(item.size)} | ${dimensions} | ${isUploaded ? "\u2601\uFE0F" : "\u{1F4C1}"} | ${tags || "No tags"}
> ${linkSection}`;
  }
  buildLinkCard(item) {
    const linkUrl = buildEagleItemUrl(item.id);
    const tags = item.tags.filter((t) => !t.startsWith("r2:") && t !== "r2-cloud").map((t) => `#${this.normalizeTag(t)}`).join(" ");
    const dimensions = item.width && item.height ? `${item.width}\xD7${item.height}` : "N/A";
    const imageUrl = this.getImageUrl(item);
    const cloudUrl = this.api.getCloudUrl(item);
    const localUrl = this.api.getLocalThumbnailUrl(item.id);
    const isUploaded = hasR2Upload(item);
    let imageSection = "";
    if (this.settings.embedImageInCard && imageUrl) {
      imageSection = `> ![${item.name}](${imageUrl})
>
`;
    }
    let linkSection = `> [Open in Eagle](${linkUrl})`;
    if (cloudUrl) {
      linkSection += ` | [Cloud URL](${cloudUrl})`;
    }
    return `> [!cmdspace-eagle] ${item.name}
> 
${imageSection}> | Property | Value |
> |----------|-------|
> | **Type** | ${item.ext.toUpperCase()} |
> | **Size** | ${this.formatFileSize(item.size)} |
> | **Dimensions** | ${dimensions} |
> | **R2 Status** | ${isUploaded ? "\u2601\uFE0F Uploaded" : "\u{1F4C1} Local only"} |
> | **Tags** | ${tags || "None"} |
${item.annotation ? `> | **Annotation** | ${item.annotation} |
` : ""}${linkSection}

`;
  }
  getImageUrl(item) {
    const cloudUrl = this.api.getCloudUrl(item);
    const localUrl = this.api.getLocalThumbnailUrl(item.id);
    switch (this.settings.imageDisplayMode) {
      case "cloud":
        return cloudUrl || localUrl;
      case "local":
        return localUrl;
      case "both":
        return cloudUrl || localUrl;
      default:
        return cloudUrl || localUrl;
    }
  }
  async refreshCurrentNoteMetadata() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian4.Notice("No active file");
      return;
    }
    const content = await this.app.vault.read(activeFile);
    const eagleLinks = this.extractEagleLinks(content);
    if (eagleLinks.length === 0) {
      new import_obsidian4.Notice("No Eagle links found in current note");
      return;
    }
    new import_obsidian4.Notice(`Found ${eagleLinks.length} Eagle links. Refreshing...`);
    for (const id of eagleLinks) {
      const item = await this.api.getItemInfo(id);
      if (item) {
        console.log(`Refreshed: ${item.name}`);
      }
    }
    new import_obsidian4.Notice("Eagle metadata refreshed");
  }
  extractEagleLinks(content) {
    const regex = /eagle:\/\/item\/([A-Z0-9]+)/gi;
    const matches = [];
    let match;
    while ((match = regex.exec(content)) !== null) {
      matches.push(match[1]);
    }
    return [...new Set(matches)];
  }
  async syncTagsToEagle() {
    var _a;
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian4.Notice("No active file");
      return;
    }
    const metadata = this.app.metadataCache.getFileCache(activeFile);
    const tags = ((_a = metadata == null ? void 0 : metadata.tags) == null ? void 0 : _a.map((t) => t.tag.replace("#", ""))) || [];
    const content = await this.app.vault.read(activeFile);
    const eagleLinks = this.extractEagleLinks(content);
    if (eagleLinks.length === 0) {
      new import_obsidian4.Notice("No Eagle links found in current note");
      return;
    }
    let updated = 0;
    for (const id of eagleLinks) {
      const success = await this.api.updateItem(id, { tags });
      if (success)
        updated++;
    }
    new import_obsidian4.Notice(`Synced tags to ${updated}/${eagleLinks.length} Eagle items`);
  }
  async syncTagsFromEagle() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian4.Notice("No active file");
      return;
    }
    const content = await this.app.vault.read(activeFile);
    const eagleLinks = this.extractEagleLinks(content);
    if (eagleLinks.length === 0) {
      new import_obsidian4.Notice("No Eagle links found in current note");
      return;
    }
    const allTags = /* @__PURE__ */ new Set();
    for (const id of eagleLinks) {
      const item = await this.api.getItemInfo(id);
      if (item) {
        item.tags.forEach((t) => allTags.add(this.normalizeTag(t)));
      }
    }
    if (allTags.size === 0) {
      new import_obsidian4.Notice("No tags found in linked Eagle items");
      return;
    }
    await this.app.fileManager.processFrontMatter(activeFile, (frontmatter) => {
      const existingTags = frontmatter.tags || [];
      const newTags = [.../* @__PURE__ */ new Set([...existingTags, ...allTags])];
      frontmatter.tags = newTags;
    });
    new import_obsidian4.Notice(`Added ${allTags.size} tags from Eagle items`);
  }
  async captureUrlToEagle(editor) {
    const clipboardText = await navigator.clipboard.readText();
    if (!clipboardText.startsWith("http://") && !clipboardText.startsWith("https://")) {
      new import_obsidian4.Notice("Clipboard does not contain a valid URL");
      return;
    }
    const connected = await this.api.isConnected();
    if (!connected) {
      new import_obsidian4.Notice("Eagle is not running");
      return;
    }
    const name = `Captured from Obsidian - ${new Date().toISOString()}`;
    const success = await this.api.addFromUrl({
      url: clipboardText,
      name,
      folderId: this.settings.defaultFolder || void 0
    });
    if (success) {
      new import_obsidian4.Notice("URL captured to Eagle");
      editor.replaceSelection(`[Captured: ${clipboardText}]`);
    } else {
      new import_obsidian4.Notice("Failed to capture URL to Eagle");
    }
  }
  async openEagleItemUnderCursor(editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    const match = line.match(/eagle:\/\/item\/([A-Z0-9]+)/i);
    if (!match) {
      new import_obsidian4.Notice("No Eagle link found on current line");
      return;
    }
    const url = `eagle://item/${match[1]}`;
    window.open(url);
  }
  async uploadClipboardToCloud(editor) {
    const clipboardText = (await navigator.clipboard.readText()).trim();
    let itemId = null;
    let directFilePath = null;
    const eagleParsed = parseEagleUrl(clipboardText);
    if (eagleParsed && eagleParsed.type === "item") {
      itemId = eagleParsed.id;
    }
    if (!itemId) {
      const localhostId = parseEagleLocalhostUrl(clipboardText);
      if (localhostId) {
        itemId = localhostId;
      }
    }
    if (!itemId && this.isEagleLibraryPath(clipboardText)) {
      directFilePath = clipboardText;
      const idMatch = clipboardText.match(/images\/([A-Z0-9]+)\.info/i);
      if (idMatch) {
        itemId = idMatch[1];
      }
    }
    if (!itemId && !directFilePath) {
      new import_obsidian4.Notice("Clipboard does not contain a valid Eagle URL or file path.\nSupported: eagle://item/ID, localhost URL, or Eagle library path");
      return;
    }
    const provider = this.getActiveCloudProvider();
    if (!provider) {
      new import_obsidian4.Notice("No cloud provider configured. Check settings.");
      return;
    }
    if (itemId) {
      const item = await this.api.getItemInfo(itemId);
      if (!item) {
        new import_obsidian4.Notice("Could not fetch item info from Eagle");
        return;
      }
      if (hasR2Upload(item)) {
        const cloudUrl = this.api.getCloudUrl(item);
        new import_obsidian4.Notice(`Already uploaded: ${cloudUrl}`);
        if (cloudUrl) {
          await navigator.clipboard.writeText(cloudUrl);
        }
        return;
      }
      new import_obsidian4.Notice(`Uploading ${item.name} to cloud...`);
      const filePath = await this.api.getOriginalFilePath(item);
      if (!filePath) {
        new import_obsidian4.Notice("Could not get file path from Eagle");
        return;
      }
      const filename = `${item.name}.${item.ext}`;
      const mimeType = getMimeType2(item.ext);
      const result = await provider.upload(filePath, filename, mimeType);
      if (result.success && result.publicUrl) {
        new import_obsidian4.Notice(`Uploaded! Cloud URL copied to clipboard`);
        await navigator.clipboard.writeText(result.publicUrl);
        const markdown = `![${filename}](${result.publicUrl})`;
        editor.replaceSelection(markdown);
        const r2Tag = `r2:${result.key}`;
        const newTags = [...item.tags];
        if (!newTags.includes(r2Tag) && result.key) {
          newTags.push(r2Tag);
        }
        if (!newTags.includes("cloud-upload")) {
          newTags.push("cloud-upload");
        }
        await this.api.updateItem(item.id, { tags: newTags });
      } else {
        new import_obsidian4.Notice(`Upload failed: ${result.error}`);
      }
    } else if (directFilePath) {
      const filename = directFilePath.split("/").pop() || "image";
      const ext = getExtFromFilename(filename);
      const mimeType = getMimeType2(ext);
      new import_obsidian4.Notice(`Uploading ${filename} to cloud...`);
      const result = await provider.upload(directFilePath, filename, mimeType);
      if (result.success && result.publicUrl) {
        new import_obsidian4.Notice(`Uploaded! Cloud URL copied to clipboard`);
        await navigator.clipboard.writeText(result.publicUrl);
        const markdown = `![${filename}](${result.publicUrl})`;
        editor.replaceSelection(markdown);
      } else {
        new import_obsidian4.Notice(`Upload failed: ${result.error}`);
      }
    }
  }
  async embedAndUploadToCloud(editor) {
    const clipboardText = (await navigator.clipboard.readText()).trim();
    let itemId = null;
    let directFilePath = null;
    const eagleParsed = parseEagleUrl(clipboardText);
    if (eagleParsed && eagleParsed.type === "item") {
      itemId = eagleParsed.id;
    }
    if (!itemId) {
      const localhostId = parseEagleLocalhostUrl(clipboardText);
      if (localhostId) {
        itemId = localhostId;
      }
    }
    if (!itemId && this.isEagleLibraryPath(clipboardText)) {
      directFilePath = clipboardText;
      const idMatch = clipboardText.match(/images\/([A-Z0-9]+)\.info/i);
      if (idMatch) {
        itemId = idMatch[1];
      }
    }
    if (!itemId && !directFilePath) {
      new import_obsidian4.Notice("Clipboard does not contain a valid Eagle URL or file path");
      return;
    }
    const provider = this.getActiveCloudProvider();
    if (!provider) {
      new import_obsidian4.Notice("No cloud provider configured. Check settings.");
      return;
    }
    const providerName = this.getActiveCloudProviderName();
    if (itemId) {
      const item = await this.api.getItemInfo(itemId);
      if (!item) {
        new import_obsidian4.Notice("Could not fetch item info from Eagle");
        return;
      }
      const filePath = await this.api.getOriginalFilePath(item);
      if (!filePath) {
        new import_obsidian4.Notice("Could not get file path from Eagle");
        return;
      }
      new import_obsidian4.Notice(`Uploading ${item.name} to ${providerName}...`);
      const filename = `${item.name}.${item.ext}`;
      const mimeType = getMimeType2(item.ext);
      const result = await provider.upload(filePath, filename, mimeType);
      if (result.success && result.publicUrl) {
        const markdown = `![${filename}](${result.publicUrl})`;
        editor.replaceSelection(markdown);
        new import_obsidian4.Notice(`Embedded and uploaded to ${providerName}!`);
        if (result.key) {
          const cloudTag = `cloud:${result.key}`;
          const newTags = [...item.tags];
          if (!newTags.includes(cloudTag)) {
            newTags.push(cloudTag);
          }
          if (!newTags.includes("cloud-upload")) {
            newTags.push("cloud-upload");
          }
          await this.api.updateItem(item.id, { tags: newTags });
        }
      } else {
        new import_obsidian4.Notice(`Upload failed: ${result.error}`);
      }
    } else if (directFilePath) {
      const filename = directFilePath.split("/").pop() || "image";
      const ext = getExtFromFilename(filename);
      const mimeType = getMimeType2(ext);
      new import_obsidian4.Notice(`Uploading ${filename} to ${providerName}...`);
      const result = await provider.upload(directFilePath, filename, mimeType);
      if (result.success && result.publicUrl) {
        const markdown = `![${filename}](${result.publicUrl})`;
        editor.replaceSelection(markdown);
        new import_obsidian4.Notice(`Embedded and uploaded to ${providerName}!`);
      } else {
        new import_obsidian4.Notice(`Upload failed: ${result.error}`);
      }
    }
  }
  processEagleLinks(el) {
    const links = el.querySelectorAll('a[href^="eagle://"]');
    links.forEach((link) => {
      const href = link.getAttribute("href");
      if (href) {
        link.addEventListener("click", (e) => {
          e.preventDefault();
          window.open(href);
        });
        link.addClass("cmdspace-eagle-link");
      }
    });
  }
  normalizeTag(tag) {
    let normalized = tag.replace(/\s+/g, "-");
    if (this.settings.tagNormalization === "lowercase") {
      normalized = normalized.toLowerCase();
    }
    if (this.settings.tagPrefix) {
      normalized = `${this.settings.tagPrefix}/${normalized}`;
    }
    return normalized;
  }
  formatFileSize(bytes) {
    if (bytes < 1024)
      return `${bytes} B`;
    if (bytes < 1024 * 1024)
      return `${(bytes / 1024).toFixed(1)} KB`;
    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
  }
  async handlePaste(evt, editor) {
    const clipboardData = evt.clipboardData;
    if (!clipboardData)
      return;
    const text = clipboardData.getData("text/plain").trim();
    if (isEagleLocalhostUrl(text)) {
      evt.preventDefault();
      await this.handleEagleLocalhostUrlPaste(text, editor);
      return;
    }
    if (this.isEagleLibraryPath(text)) {
      evt.preventDefault();
      await this.handleEagleLibraryPathPaste(text, editor);
      return;
    }
    const { files } = clipboardData;
    if (!files || !this.allFilesAreImages(files))
      return;
    if (this.settings.imagePasteBehavior === "local") {
      return;
    }
    evt.preventDefault();
    const filesCopy = Array.from(files);
    if (this.settings.imagePasteBehavior === "eagle") {
      for (const file of filesCopy) {
        await this.uploadFileWithProgress(file, editor);
      }
      return;
    }
    if (this.settings.imagePasteBehavior === "cloud") {
      for (const file of filesCopy) {
        await this.uploadToCloudWithProgress(file, editor);
      }
      return;
    }
    const cloudProviderName = this.getActiveCloudProviderName();
    const modal = new ImagePasteChoiceModal(this.app, cloudProviderName);
    modal.open();
    const response = await modal.getResponse();
    if (response.rememberChoice && response.choice !== "cancel") {
      this.settings.imagePasteBehavior = response.choice;
      await this.saveSettings();
    }
    if (response.choice === "eagle") {
      for (const file of filesCopy) {
        await this.uploadFileWithProgress(file, editor);
      }
    } else if (response.choice === "local") {
      for (const file of filesCopy) {
        await this.saveImageLocally(file, editor);
      }
    } else if (response.choice === "cloud") {
      for (const file of filesCopy) {
        await this.uploadToCloudWithProgress(file, editor);
      }
    }
  }
  async handleDrop(evt, editor) {
    const { files } = evt.dataTransfer || { files: null };
    if (!files || !this.allFilesAreImages(files))
      return;
    if (this.settings.imagePasteBehavior === "local") {
      return;
    }
    evt.preventDefault();
    const filesCopy = Array.from(files);
    if (this.settings.imagePasteBehavior === "eagle") {
      for (const file of filesCopy) {
        await this.uploadFileWithProgress(file, editor);
      }
      return;
    }
    if (this.settings.imagePasteBehavior === "cloud") {
      for (const file of filesCopy) {
        await this.uploadToCloudWithProgress(file, editor);
      }
      return;
    }
    const cloudProviderName = this.getActiveCloudProviderName();
    const modal = new ImagePasteChoiceModal(this.app, cloudProviderName);
    modal.open();
    const response = await modal.getResponse();
    if (response.rememberChoice && response.choice !== "cancel") {
      this.settings.imagePasteBehavior = response.choice;
      await this.saveSettings();
    }
    if (response.choice === "eagle") {
      for (const file of filesCopy) {
        await this.uploadFileWithProgress(file, editor);
      }
    } else if (response.choice === "local") {
      for (const file of filesCopy) {
        await this.saveImageLocally(file, editor);
      }
    } else if (response.choice === "cloud") {
      for (const file of filesCopy) {
        await this.uploadToCloudWithProgress(file, editor);
      }
    }
  }
  async saveImageLocally(file, editor) {
    var _a, _b, _c;
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian4.Notice("No active file");
      return;
    }
    try {
      const buffer = await file.arrayBuffer();
      const timestamp = Date.now();
      const filename = `${timestamp}-${file.name}`;
      const vault = this.app.vault;
      const attachmentFolder = ((_a = vault.getConfig) == null ? void 0 : _a.call(vault, "attachmentFolderPath")) || "";
      let targetPath;
      if (attachmentFolder === "./") {
        const parentFolder = ((_b = activeFile.parent) == null ? void 0 : _b.path) || "";
        targetPath = parentFolder ? `${parentFolder}/${filename}` : filename;
      } else if (attachmentFolder.startsWith("./")) {
        const parentFolder = ((_c = activeFile.parent) == null ? void 0 : _c.path) || "";
        const relativeFolder = attachmentFolder.slice(2);
        targetPath = parentFolder ? `${parentFolder}/${relativeFolder}/${filename}` : `${relativeFolder}/${filename}`;
      } else if (attachmentFolder) {
        targetPath = `${attachmentFolder}/${filename}`;
      } else {
        targetPath = filename;
      }
      const folderPath = targetPath.substring(0, targetPath.lastIndexOf("/"));
      if (folderPath) {
        const folderExists = await this.app.vault.adapter.exists(folderPath);
        if (!folderExists) {
          await this.app.vault.createFolder(folderPath);
        }
      }
      await this.app.vault.createBinary(targetPath, buffer);
      const markdownImage = `![${file.name}](${encodeURI(targetPath)})`;
      editor.replaceSelection(markdownImage);
      new import_obsidian4.Notice(`Saved locally: ${file.name}`);
    } catch (error) {
      console.error("Failed to save image locally:", error);
      new import_obsidian4.Notice(`Failed to save: ${file.name}`);
    }
  }
  async uploadFileWithProgress(file, editor) {
    const pasteId = this.generatePasteId();
    const placeholderText = `![Uploading ${file.name}...](${pasteId})`;
    editor.replaceSelection(placeholderText);
    try {
      const imageUrl = await this.uploadImageToEagle(file);
      const markdownImage = `![${file.name}](${imageUrl})`;
      this.replaceTextInDocument(editor, placeholderText, markdownImage);
      new import_obsidian4.Notice(`Uploaded to Eagle: ${file.name}`);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      const errorText = `<!-- Failed to upload ${file.name}: ${errorMessage} -->`;
      this.replaceTextInDocument(editor, placeholderText, errorText);
      console.error("Failed to upload image:", error);
      new import_obsidian4.Notice(`Failed to upload: ${file.name}`);
    }
  }
  async uploadToCloudWithProgress(file, editor) {
    const provider = this.getActiveCloudProvider();
    if (!provider) {
      new import_obsidian4.Notice("No cloud provider configured");
      return;
    }
    const pasteId = this.generatePasteId();
    const providerName = this.getActiveCloudProviderName();
    const placeholderText = `![Uploading to ${providerName}...](${pasteId})`;
    editor.replaceSelection(placeholderText);
    try {
      const tempPath = await this.saveToTempLocation(file);
      const ext = getExtFromFilename(file.name);
      const mimeType = getMimeType2(ext);
      const result = await provider.upload(tempPath, file.name, mimeType);
      if (result.success && result.publicUrl) {
        const markdownImage = `![${file.name}](${result.publicUrl})`;
        this.replaceTextInDocument(editor, placeholderText, markdownImage);
        new import_obsidian4.Notice(`Uploaded to ${providerName}: ${file.name}`);
      } else {
        throw new Error(result.error || "Upload failed");
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      const errorText = `<!-- Failed to upload ${file.name}: ${errorMessage} -->`;
      this.replaceTextInDocument(editor, placeholderText, errorText);
      console.error("Failed to upload to cloud:", error);
      new import_obsidian4.Notice(`Failed to upload: ${file.name}`);
    }
  }
  getActiveCloudProvider() {
    const providerType = this.settings.activeCloudProvider;
    const config = this.settings.cloudProviders[providerType];
    if (!config || !config.enabled) {
      if (this.settings.r2WorkerUrl && this.settings.r2ApiKey) {
        return createCloudProvider({
          type: "r2",
          enabled: true,
          name: "Cloudflare R2",
          workerUrl: this.settings.r2WorkerUrl,
          apiKey: this.settings.r2ApiKey,
          publicUrl: this.settings.r2PublicUrl
        });
      }
      return null;
    }
    return createCloudProvider(config);
  }
  getActiveCloudProviderName() {
    const providerType = this.settings.activeCloudProvider;
    const config = this.settings.cloudProviders[providerType];
    if ((config == null ? void 0 : config.enabled) && (config == null ? void 0 : config.name)) {
      return config.name;
    }
    if (this.settings.r2WorkerUrl) {
      return "Cloudflare R2";
    }
    return "Cloud";
  }
  replaceTextInDocument(editor, searchText, replaceText) {
    const content = editor.getValue();
    const index = content.indexOf(searchText);
    if (index === -1)
      return;
    const startPos = editor.offsetToPos(index);
    const endPos = editor.offsetToPos(index + searchText.length);
    editor.replaceRange(replaceText, startPos, endPos);
  }
  generatePasteId() {
    return `paste-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
  }
  getLocalImageUnderCursor(editor) {
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    const supportedExtensions = ["png", "jpg", "jpeg", "gif", "bmp", "svg", "webp"];
    const extensionPattern = supportedExtensions.join("|");
    const wikilinkPattern = new RegExp(`!\\[\\[([^\\]]+\\.(${extensionPattern}))\\]\\]`, "gi");
    const markdownPattern = new RegExp(`!\\[([^\\]]*)\\]\\(([^)]+\\.(${extensionPattern}))\\)`, "gi");
    let match;
    wikilinkPattern.lastIndex = 0;
    while ((match = wikilinkPattern.exec(line)) !== null) {
      const start = match.index;
      const end = start + match[0].length;
      if (cursor.ch >= start && cursor.ch <= end) {
        const filename = match[1];
        const file = this.app.metadataCache.getFirstLinkpathDest(filename, "");
        if (file instanceof import_obsidian4.TFile) {
          return {
            file,
            startPos: { line: cursor.line, ch: start },
            endPos: { line: cursor.line, ch: end },
            originalText: match[0]
          };
        }
      }
    }
    markdownPattern.lastIndex = 0;
    while ((match = markdownPattern.exec(line)) !== null) {
      const start = match.index;
      const end = start + match[0].length;
      if (cursor.ch >= start && cursor.ch <= end) {
        const filepath = match[2];
        if (!filepath.startsWith("http") && !filepath.startsWith("file://") && !filepath.startsWith("eagle://")) {
          const file = this.app.metadataCache.getFirstLinkpathDest(filepath, "");
          if (file instanceof import_obsidian4.TFile) {
            return {
              file,
              startPos: { line: cursor.line, ch: start },
              endPos: { line: cursor.line, ch: end },
              originalText: match[0]
            };
          }
        }
      }
    }
    return null;
  }
  async uploadLocalImageToEagle(editor, localImage) {
    const { file, startPos, endPos, originalText } = localImage;
    const placeholderText = `![Uploading ${file.name}...](uploading)`;
    editor.replaceRange(placeholderText, startPos, endPos);
    try {
      const connected = await this.api.isConnected();
      if (!connected) {
        throw new Error("Eagle is not running");
      }
      const absolutePath = this.getAbsolutePath(file.path);
      const filenameWithoutExt = file.basename;
      const result = await this.api.addFromPath({
        path: absolutePath,
        name: filenameWithoutExt,
        folderId: this.settings.defaultFolder || void 0
      });
      if (!result.success || !result.itemId) {
        throw new Error("Failed to add image to Eagle");
      }
      await this.delay(1e3);
      const thumbnailPath = await this.api.getThumbnailPath(result.itemId);
      const imageUrl = thumbnailPath ? `file://${thumbnailPath}` : `eagle://item/${result.itemId}`;
      const markdownImage = `![${file.basename}](${imageUrl})`;
      this.replaceTextInDocument(editor, placeholderText, markdownImage);
      new import_obsidian4.Notice(`Uploaded to Eagle: ${file.name}`);
      await this.offerToReplaceOtherReferences(file, imageUrl, { line: startPos.line, ch: startPos.ch });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      this.replaceTextInDocument(editor, placeholderText, originalText);
      new import_obsidian4.Notice(`Failed to upload: ${errorMessage}`);
    }
  }
  async offerToReplaceOtherReferences(originalFile, newUrl, excludePosition) {
    const references = this.findAllReferencesToFile(originalFile);
    const filteredRefs = [];
    for (const ref of references) {
      const filteredPositions = ref.positions.filter((pos) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile && ref.notePath === activeFile.path) {
          return !(pos.line === excludePosition.line && pos.ch === excludePosition.ch);
        }
        return true;
      });
      if (filteredPositions.length > 0) {
        filteredRefs.push({ notePath: ref.notePath, positions: filteredPositions });
      }
    }
    if (filteredRefs.length === 0)
      return;
    const totalCount = filteredRefs.reduce((sum, ref) => sum + ref.positions.length, 0);
    const fileCount = filteredRefs.length;
    const shouldReplace = await this.confirmReplaceReferences(totalCount, fileCount, originalFile.name);
    if (!shouldReplace)
      return;
    await this.replaceAllReferences(filteredRefs, originalFile, newUrl);
    new import_obsidian4.Notice(`Replaced ${totalCount} references in ${fileCount} files`);
  }
  findAllReferencesToFile(targetFile) {
    const results = [];
    const allFiles = this.app.vault.getMarkdownFiles();
    for (const file of allFiles) {
      const cache = this.app.metadataCache.getFileCache(file);
      if (!(cache == null ? void 0 : cache.embeds))
        continue;
      const positions = [];
      for (const embed of cache.embeds) {
        const linkedFile = this.app.metadataCache.getFirstLinkpathDest(embed.link, file.path);
        if (linkedFile === targetFile) {
          positions.push({
            line: embed.position.start.line,
            ch: embed.position.start.col,
            text: embed.original
          });
        }
      }
      if (positions.length > 0) {
        results.push({ notePath: file.path, positions });
      }
    }
    return results;
  }
  async confirmReplaceReferences(count, fileCount, filename) {
    return new Promise((resolve) => {
      const notice = new import_obsidian4.Notice(
        `Found ${count} other references to "${filename}" in ${fileCount} files. Click to replace all with Eagle link.`,
        1e4
      );
      const noticeEl = notice.noticeEl;
      noticeEl.style.cursor = "pointer";
      noticeEl.onclick = () => {
        notice.hide();
        resolve(true);
      };
      setTimeout(() => resolve(false), 1e4);
    });
  }
  async replaceAllReferences(references, originalFile, newUrl) {
    for (const ref of references) {
      const file = this.app.vault.getAbstractFileByPath(ref.notePath);
      if (!(file instanceof import_obsidian4.TFile))
        continue;
      let content = await this.app.vault.read(file);
      const sortedPositions = [...ref.positions].sort((a, b) => {
        if (a.line !== b.line)
          return b.line - a.line;
        return b.ch - a.ch;
      });
      for (const pos of sortedPositions) {
        const newMarkdown = `![${originalFile.basename}](${newUrl})`;
        const lines = content.split("\n");
        const line = lines[pos.line];
        if (line) {
          const index = line.indexOf(pos.text, pos.ch);
          if (index !== -1) {
            lines[pos.line] = line.substring(0, index) + newMarkdown + line.substring(index + pos.text.length);
            content = lines.join("\n");
          }
        }
      }
      await this.app.vault.modify(file, content);
    }
  }
  async handleEagleLocalhostUrlPaste(url, editor) {
    const itemId = parseEagleLocalhostUrl(url);
    if (!itemId) {
      new import_obsidian4.Notice("Invalid Eagle URL");
      return;
    }
    const item = await this.api.getItemInfo(itemId);
    if (!item) {
      new import_obsidian4.Notice("Could not fetch item info from Eagle");
      return;
    }
    const filePath = await this.getEagleItemFilePath(itemId, item.name, item.ext);
    if (filePath) {
      const fileUrl = this.pathToFileUrl(filePath);
      const filename = `${item.name}.${item.ext}`;
      const markdown = `![${filename}](${fileUrl})`;
      editor.replaceSelection(markdown);
      new import_obsidian4.Notice(`Embedded: ${filename}`);
    } else {
      new import_obsidian4.Notice("Could not get file path from Eagle");
    }
  }
  isEagleLibraryPath(text) {
    return text.includes(".library/images/") && text.includes(".info/");
  }
  async handleEagleLibraryPathPaste(path, editor) {
    const filename = path.split("/").pop() || "image";
    const fileUrl = this.pathToFileUrl(path);
    const markdown = `![${filename}](${fileUrl})`;
    editor.replaceSelection(markdown);
    new import_obsidian4.Notice(`Embedded: ${filename}`);
  }
  async getEagleItemFilePath(itemId, name, ext) {
    const thumbnailPath = await this.api.getThumbnailPath(itemId);
    if (!thumbnailPath)
      return null;
    const decodedPath = this.safeDecodeUri(thumbnailPath);
    const folderPath = decodedPath.substring(0, decodedPath.lastIndexOf("/"));
    const originalFileName = `${name}.${ext}`;
    return `${folderPath}/${originalFileName}`;
  }
  safeDecodeUri(str) {
    try {
      return decodeURIComponent(str);
    } catch (e) {
      return str;
    }
  }
  pathToFileUrl(path) {
    const encodedPath = path.split("/").map((segment) => encodeURIComponent(segment)).join("/");
    return `file://${encodedPath}`;
  }
  async uploadImageToEagle(file) {
    const tempPath = await this.saveToTempLocation(file);
    const connected = await this.api.isConnected();
    if (!connected) {
      throw new Error("Eagle is not running");
    }
    const filenameWithoutExt = file.name.replace(/\.[^.]+$/, "");
    const result = await this.api.addFromPath({
      path: tempPath,
      name: filenameWithoutExt,
      folderId: this.settings.defaultFolder || void 0
    });
    if (!result.success || !result.itemId) {
      throw new Error("Failed to add image to Eagle");
    }
    await this.delay(1e3);
    const thumbnailPath = await this.api.getThumbnailPath(result.itemId);
    return thumbnailPath ? `file://${thumbnailPath}` : `file://${tempPath}`;
  }
  async saveToTempLocation(file) {
    const tempDir = ".eagle-temp";
    const tempDirPath = `${tempDir}`;
    const adapter = this.app.vault.adapter;
    const tempDirExists = await adapter.exists(tempDirPath);
    if (!tempDirExists) {
      await adapter.mkdir(tempDirPath);
    }
    const timestamp = Date.now();
    const filename = `${timestamp}-${file.name}`;
    const tempFilePath = `${tempDirPath}/${filename}`;
    const buffer = await file.arrayBuffer();
    const uint8Array = new Uint8Array(buffer);
    await adapter.writeBinary(tempFilePath, uint8Array);
    return this.getAbsolutePath(tempFilePath);
  }
  getVaultPath() {
    const adapter = this.app.vault.adapter;
    if (adapter.basePath) {
      return adapter.basePath;
    }
    const configDir = this.app.vault.configDir;
    return configDir.replace("/.obsidian", "");
  }
  getAbsolutePath(relativePath) {
    const vaultPath = this.getVaultPath();
    if (relativePath.startsWith("/")) {
      return relativePath;
    }
    return `${vaultPath}/${relativePath}`;
  }
  delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  allFilesAreImages(files) {
    if (!files || files.length === 0)
      return false;
    const imageTypes = [
      "image/jpeg",
      "image/jpg",
      "image/png",
      "image/gif",
      "image/webp",
      "image/bmp"
    ];
    for (const file of Array.from(files)) {
      if (!imageTypes.includes(file.type)) {
        return false;
      }
    }
    return true;
  }
  async uploadAllImagesToCloud() {
    const provider = this.getActiveCloudProvider();
    if (!provider) {
      new import_obsidian4.Notice("No cloud provider configured. Check settings.");
      return;
    }
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian4.Notice("No active file");
      return;
    }
    const content = await this.app.vault.read(activeFile);
    const providerName = this.getActiveCloudProviderName();
    const imageMatches = [];
    const fileUrlRegex = /!\[([^\]]*)\]\((file:\/\/[^)]+)\)/gi;
    let match;
    while ((match = fileUrlRegex.exec(content)) !== null) {
      const url = match[2];
      const filePath = decodeURIComponent(url.replace("file://", ""));
      imageMatches.push({
        full: match[0],
        alt: match[1],
        url,
        filePath
      });
    }
    const localhostRegex = /!\[([^\]]*)\]\((https?:\/\/localhost:\d+\/api\/item\/thumbnail\?id=([A-Z0-9]+))\)/gi;
    while ((match = localhostRegex.exec(content)) !== null) {
      const itemId = match[3];
      const item = await this.api.getItemInfo(itemId);
      if (item) {
        const filePath = await this.api.getOriginalFilePath(item);
        if (filePath) {
          imageMatches.push({
            full: match[0],
            alt: match[1],
            url: match[2],
            filePath
          });
        }
      }
    }
    const localImageRegex = /!\[([^\]]*)\]\((?!https?:\/\/|file:\/\/)([^)]+\.(jpg|jpeg|png|gif|webp|mp4|mov))\)/gi;
    while ((match = localImageRegex.exec(content)) !== null) {
      const relativePath = match[2];
      const absolutePath = this.getAbsolutePath(relativePath);
      imageMatches.push({
        full: match[0],
        alt: match[1],
        url: relativePath,
        filePath: absolutePath
      });
    }
    if (imageMatches.length === 0) {
      new import_obsidian4.Notice("No local images found in current note");
      return;
    }
    new import_obsidian4.Notice(`Found ${imageMatches.length} images. Uploading to ${providerName}...`);
    let uploaded = 0;
    let newContent = content;
    for (const img of imageMatches) {
      if (!img.filePath)
        continue;
      if (img.url.startsWith("http://") || img.url.startsWith("https://")) {
        if (!img.url.includes("localhost"))
          continue;
      }
      const filename = img.filePath.split("/").pop() || "image";
      const ext = getExtFromFilename(filename);
      const mimeType = getMimeType2(ext);
      try {
        const result = await provider.upload(img.filePath, filename, mimeType);
        if (result.success && result.publicUrl) {
          newContent = newContent.replace(img.url, result.publicUrl);
          uploaded++;
        }
      } catch (error) {
        console.error(`Failed to upload ${filename}:`, error);
      }
    }
    if (newContent !== content) {
      await this.app.vault.modify(activeFile, newContent);
    }
    new import_obsidian4.Notice(`Uploaded ${uploaded}/${imageMatches.length} images to ${providerName}`);
  }
};
